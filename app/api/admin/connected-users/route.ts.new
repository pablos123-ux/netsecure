import { NextRequest, NextResponse } from 'next/server';
import { requireAuth } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { withErrorHandling, paginationSchema, ApiError } from '@/lib/api-utils';
import { z } from 'zod';

// Validation schemas
const connectedUsersQuerySchema = z.object({
  role: z.enum(['ADMIN', 'STAFF', 'USER']).optional(),
  isActive: z.enum(['true', 'false']).transform(val => val === 'true').optional(),
  lastActive: z.enum(['24h', '7d', '30d', '90d']).optional(),
  search: z.string().optional(),
  provinceId: z.string().uuid().optional(),
  districtId: z.string().uuid().optional()
});

// GET /api/admin/connected-users
export async function GET(request: NextRequest) {
  return withErrorHandling(async () => {
    await requireAuth(request, ['ADMIN', 'STAFF']);
    
    const { searchParams } = new URL(request.url);
    
    // Parse and validate query params
    const query = {
      ...paginationSchema.parse({
        page: searchParams.get('page'),
        limit: searchParams.get('limit'),
        sortBy: searchParams.get('sortBy') || 'lastActive',
        sortOrder: searchParams.get('sortOrder') || 'desc'
      }),
      ...connectedUsersQuerySchema.parse({
        role: searchParams.get('role') as any,
        isActive: searchParams.get('isActive') as any,
        lastActive: searchParams.get('lastActive'),
        search: searchParams.get('search'),
        provinceId: searchParams.get('provinceId'),
        districtId: searchParams.get('districtId')
      })
    };

    // Build the where clause
    const where: any = {
      role: { in: ['ADMIN', 'STAFF', 'USER'] } // Only these roles can be connected users
    };

    // Apply filters
    if (query.role) where.role = query.role;
    if (query.isActive !== undefined) where.isActive = query.isActive;
    
    // Apply location filters
    if (query.districtId) {
      where.assignedDistrictId = query.districtId;
    } else if (query.provinceId) {
      where.assignedProvinceId = query.provinceId;
    }

    // Apply search
    if (query.search) {
      where.OR = [
        { name: { contains: query.search, mode: 'insensitive' } },
        { email: { contains: query.search, mode: 'insensitive' } }
      ];
    }

    // Apply last active filter
    if (query.lastActive) {
      const lastActiveDate = new Date();
      const days = parseInt(query.lastActive);
      if (!isNaN(days)) {
        lastActiveDate.setDate(lastActiveDate.getDate() - days);
        where.lastLogin = { gte: lastActiveDate };
      }
    }

    // Get total count and paginated results in parallel
    const [total, users] = await Promise.all([
      prisma.user.count({ where }),
      prisma.user.findMany({
        where,
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
          isActive: true,
          lastLogin: true,
          assignedProvince: {
            select: {
              id: true,
              name: true
            }
          },
          assignedDistrict: {
            select: {
              id: true,
              name: true
            }
          },
          _count: {
            select: {
              sessions: {
                where: { expiresAt: { gt: new Date() } }
              },
              logs: true
            }
          },
          // Get the most recent activity
          logs: {
            take: 1,
            orderBy: { timestamp: 'desc' },
            select: {
              id: true,
              action: true,
              actionType: true,
              timestamp: true,
              ipAddress: true,
              userAgent: true
            }
          }
        },
        orderBy: {
          [query.sortBy === 'lastActive' ? 'lastLogin' : query.sortBy]: query.sortOrder
        },
        skip: (query.page - 1) * query.limit,
        take: query.limit
      })
    ]);

    // Format the response
    const formattedUsers = users.map(user => ({
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
      isActive: user.isActive,
      lastLogin: user.lastLogin,
      isOnline: user._count.sessions > 0,
      activityCount: user._count.logs,
      location: {
        province: user.assignedProvince,
        district: user.assignedDistrict
      },
      lastActivity: user.logs[0] ? {
        id: user.logs[0].id,
        action: user.logs[0].action,
        actionType: user.logs[0].actionType,
        timestamp: user.logs[0].timestamp,
        ipAddress: user.logs[0].ipAddress,
        userAgent: user.logs[0].userAgent
      } : null
    }));

    return NextResponse.json({
      success: true,
      data: formattedUsers,
      pagination: {
        total,
        page: query.page,
        limit: query.limit,
        totalPages: Math.ceil(total / query.limit)
      }
    });
  }, { 
    action: 'GET_CONNECTED_USERS'
  });
}

// POST /api/admin/connected-users (for testing/creating test users)
export async function POST(request: NextRequest) {
  return withErrorHandling(async () => {
    const admin = await requireAuth(request, 'ADMIN');
    
    const data = await request.json();
    
    const validation = z.object({
      name: z.string().min(2, 'Name must be at least 2 characters'),
      email: z.string().email('Invalid email address'),
      role: z.enum(['ADMIN', 'STAFF', 'USER']).default('USER'),
      isActive: z.boolean().default(true),
      lastLogin: z.string().datetime().optional(),
      assignedProvinceId: z.string().uuid().optional(),
      assignedDistrictId: z.string().uuid().optional()
    }).safeParse(data);
    
    if (!validation.success) {
      throw new ApiError(400, 'Validation failed', validation.error.errors);
    }

    // Check if email already exists
    const existingUser = await prisma.user.findUnique({
      where: { email: validation.data.email }
    });

    if (existingUser) {
      throw new ApiError(409, 'Email already in use');
    }

    // Create a test user (without password for security)
    const user = await prisma.user.create({
      data: {
        name: validation.data.name,
        email: validation.data.email,
        role: validation.data.role,
        isActive: validation.data.isActive,
        lastLogin: validation.data.lastLogin ? new Date(validation.data.lastLogin) : null,
        assignedProvinceId: validation.data.assignedProvinceId || null,
        assignedDistrictId: validation.data.assignedDistrictId || null
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        isActive: true,
        lastLogin: true,
        assignedProvince: {
          select: { id: true, name: true }
        },
        assignedDistrict: {
          select: { id: true, name: true }
        }
      }
    });

    return NextResponse.json(
      { success: true, data: user },
      { status: 201 }
    );
  }, { 
    action: 'CREATE_TEST_USER',
    userId: (await requireAuth(request, 'ADMIN')).id
  });
}
